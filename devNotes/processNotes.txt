Process Notes for React Event Handlers Study
============================================




About Process Notes
===================
"Process Notes" is a step-by-step workflow document that outlines the "phases" of my study/app development and the successive steps taken at each
milestone of the examination. In the case of studies, the process notes might be eschewed in favor of the main Readme document in the repository, 
mostly because of the advantage in formatting and accessibility. However, I will put additional notes and resource links that might be helpful. In 
the case of application development, groups of related steps are combined into "phase" modules so that they can be reorganized and refined in 
post-review. This has proven to be EXTREMELY helpful in learning (i.e. Feynman technique (https://fs.blog/2012/04/feynman-technique/)) and refining 
workflow so I can improve my process in future projects. It also has come in handy for some tricky bug fixes not only for past projects, but this 
one as well so I would urge you to consider at least doing a rough summary for your own benefit.



Objective of Study
==================
To outline the process to conditionally render nodes based on state and write event handlers.

When building React components, you often will want to render certain elements under certain conditions. To do this you need to use conditional rendering.
Using state and conditional logic, we can show or hide certain elements in a render. For example, you can have a "Tabs" component that has three buttons that,
when clicked, will "render" one content tab.

IN order to test components that update state and conditions based on events, like button clicks, you need to you the testing library called "enzyme". 
Enzyme is a test helper that you can use to create a subtree of elements using a shallow render. Within the subtree of elements, we can traverse of specific
elements and simulate events on those elements, such as clicks.









What is conditional rendering?
==============================
Conditional rendering means rendering certain nodes only at certain times. With conditional rendering, state can be used to make content appear 
and disappear from the page by meeting certain conditions







Tabs workflow
==============

// Create the TEST.
====================
1. Create a test for the Tabs component.
  --------------------------------------------------------------------
    import React from 'react';
    import ReactDOM from 'react-dom';
    import Tabs from './Tabs';

    describe(`Tabs Component`, () => {                                       // test suite for tabs component...
      it('renders without errors', () => {                                   // ... that tests for rendering without error:
        const div = document.createElement('div');                           // Variable creates a div element.
        ReactDOM.render(<Tabs />, div);                                      // ... and renders the element "Tabs" to the container "div".
        ReactDOM.unmountComponentAtNode(div);                                // Then remove the mounted React component
      })
    })
  --------------------------------------------------------------------

// Create the component
2. Create a basic component.
  --------------------------------------------------------------------
    import React from "react";

    class Tabs extends React.Component {                                     // "Tabs" component.
      render() {
        return <div />                                                       // ... that renders a div (for now just to see if the tests work).
      }
    }

    export default Tabs;
  --------------------------------------------------------------------

// TEST.
  3. Try the test to see if it works.
  ---------------------------------------------------------------------
    PASS src/state/state/Tabs.test.js
      Tabs Component
        âˆš renders without errors (13ms)

    Test Suites: 1 passed, 1 total
    Tests:       1 passed, 1 total
    Snapshots:   0 total
    Time:        2.587s
    Ran all test suites related to changed files.

  ---------------------------------------------------------------------

// Add props for accordion
  4. Add an external tabsProp and add it as a prop of the Tabs component.
  * For tabs, we plan on having a collapsible menu of content items. To do this we need 
  to create a tabsProp variable with an array of objects that have each and every tab we want 
  to be selectable.
  ---------------------------------------------------------------------
    const tabsProp = [                                                     // external tabs prop
      { name: 'First tab',
        content: 'Lorem ipsum dolor sit amet ...' },
      { name: 'Second tab',
        content: 'Laboriosam exercitationem ...' },
      { name: 'Third tab',
        content: 'Fugit, sapiente aspernatur...' },
    ];

    class App extends React.Component {
      render() {
        return <div>
          <Tabs tabs={tabsProp} />                                         // tabsProp as a prop to this Tabs component instance.
        </div>
      }
    }
  ---------------------------------------------------------------------



//// At this point, the component should be working fine and testing fine.



// Render the buttons
5. Render the Buttons for each of the buttons of the accordion:
  * For the buttons themselves, we create a constant called "buttons" that will map off the tabs array to make an array 
    of buttons. In this case, we'll use the name.
  * Note here that an error will be created because if you try to use the .map method when you DONT have a .props.tabs, you will
    essentially be saying "undefined.map" and it will not work.  You need to se defaultProps and "tabs".
  --------------------------------------------------------------------------
    class Tabs extends React.Component {
      static defaultProps = { tabs: [] };                                    // First, set defaultProps to access the "tabs" in props.
      render() {
        const buttons = this.props.tabs.map((tab, index) => (                // "buttons" maps props.tabs and for each item (i.e. tab) in the index, the tab.name goes inside a button element.
          <button key={index}>
            {tab.name}
          </button>
        ))
        return (                                                             // And then "buttons" is returned inside a seperate div.
          <div>
            {buttons}
          </div>
        )
      }
    }
  --------------------------------------------------------------------------


6. Render first tab by default
* This means that the content for the first tab is going to show. To execute this, we need ot create a current tab const
  and set this to the first prop (tab.props.tab[0]);
  --------------------------------------------------------------------------
    class Tabs extends React.Component {
      static defaultProps = { tabs: [] };
      render() {
        const buttons = this.props.tabs.map((tab, index) => (
          <button key={index}>
            {tab.name}
          </button>
        ));
        const currentTab = this.props.tabs[0];                               // current tab set at index of 0 (first in the arracy of objects)/
        return (
          <div>
            {buttons}
            {this.props.tabs.length && (                                     // content.
              <div className='content'>
                {currentTab.content}
              </div>
            )}
          </div>
        )
      }
    }
  --------------------------------------------------------------------------


7. Create a snapshot of the component so far.
* To create a snapshot, ,make sure you install 'react-test-renderer' as a local dependency and then import
  the package to your test file (i.e. import renderer from 'react-test-renderer';).
* Also remember that when you run this test, a snapshots folder will be created in your src folder and should
  be committed to your repository for others to reference as well.
  -----------------------------------------------------------------------------
      const tabsProp = [
        { name: 'First tab',
          content: 'Lorem ipsum dolor sit amet consectetur adipisicing elit. Laboriosam exercitationem quos consectetur expedita consequatur. Fugit, sapiente aspernatur corporis velit, dolor eum reprehenderit provident ipsam, maiores incidunt repellat! Facilis, neque doloremque.' },
        { name: 'Second tab',
          content: 'Laboriosam exercitationem quos consectetur expedita consequatur. Fugit, sapiente aspernatur corporis velit, dolor eum reprehenderit provident ipsam, maiores incidunt repellat! Facilis, neque doloremque. Lorem ipsum dolor sit amet consectetur adipisicing elit.' },
        { name: 'Third tab',
          content: 'Fugit, sapiente aspernatur corporis velit, dolor eum reprehenderit provident ipsam, maiores incidunt repellat! Facilis, neque doloremque. Lorem ipsum dolor sit amet consectetur adipisicing elit. Laboriosam exercitationem quos consectetur expedita consequatur.' },
      ];

      it('renders the first tab by default', () => {
        const tree = renderer.create(<Tabs tabs={tabsProp} />).toJSON()
        expect(tree).toMatchSnapshot()
      })
  -----------------------------------------------------------------------------



8. Refactoring code to make it more readable.
  ----------------------------------------------------------------
      class Tabs extends React.Component {
        static defaultProps = { tabs: [] };
        renderButtons() {                                             // Button function.
          return this.props.tabs.map((tab, index) => (
            <button key={index}>
              {tab.name}
            </button>
          ))
        }
        renderContent() {                                             // Content function.
          const currentTab = this.props.tabs[0]
          return (
            <div className='content'>
              {currentTab.content}
            </div>
          )
        } 
        render() { 
          return (
            <div>
              {this.renderButtons()}                                  // Buttons function moved to a seperate function (and called with parentheses).
              {this.props.tabs.length && this.renderContent()}        // Content moved to a seperate function.
            </div>
          )
        }
      }
  -----------------------------------------------------------------


9. Hookup the buttons 
  * For the buttons, onClick we want the buttons to show thier respective content.
  * First, instead of hardcoding the state of 0 in the current tab, we create a state property and set the 
     currentTabIndex to 0 and then pass that value in to the render content.
  ------------------------------------------------------------------
      class Tabs extends React.Component {
        static defaultProps = { 
          tabs: [] 
        };
        state = {
          currentTabIndex: 0                                                     // state of current tab
        };
        renderButtons() {
          return this.props.tabs.map((tab, index) => (
            <button key={index}>
              {tab.name}
            </button>
          ))
        }
        renderContent() {
          const currentTab = this.props.tabs[this.state.currentTabIndex];         // currentTab current state
          return (
            <div className='content'>
              {currentTab.content}
            </div>
          )
        } 
        render() { 
          return (
            <div>
              {this.renderButtons()}
              {this.props.tabs.length && this.renderContent()}
            </div>
          )
        }
      }
  ------------------------------------------------------------------

  10. Add the basic event handler to the buttons.
  * And to add a basic event handler, all you need to do is add a "onClick" prop that accesses 
    an exteranl "handleButtonClick" function. For now, all you need to do is test it by logging
    a simple message to the console.
  --------------------------------------------------------------------
      class Tabs extends React.Component {
          static defaultProps = { 
            tabs: [] 
          };
          state = {
            currentTabIndex: 0    
          };
          handleButtonClick(index) {                                                 // And add external function with Initial button click notification.
            console.log('button clicked!', { index })
          }
          renderButtons() {
            return this.props.tabs.map((tab, index) => (
              <button key={index} onClick={() => this.handleButtonClick(index)}>      // click event handler add to button with "onClick"
                {tab.name}
              </button>
            ))
          }

  --------------------------------------------------------------------





How do you test Event listeners?
================================

To test a component more comprehensively, you should take another snapshot.
However, you cant click on buttons in tests using ```react-test-renderer```.
In order to test buttons is "enzyme".
Enzyme is a tetsing library purposefully built for testing React components.
Enzyme has many features, including inspecting state, debugging, traversing nodes, etc.


Install enzyme:   npm install enzyme enzyme-adapter-react-16 --save-dev



















========SIMPLE EXAMPLE=====================
Reform with emphasis on event handlers
===========================================
How do you implement event listeners?
===========================================
* Events and state go hand in hand.
* It is VERY common to update state in response to a users action (i.e. submitting the form, interaction with a control, clicking a button, etc.).

For this example, we'll make a basic clicker. We set the state at zero for the initial count and then reference it in the component using this.state.count.
---------------------------------------------------------
  class Counter extends React.Component {
    constructor(props) {
      super(props)
      this.state = { 
        count: 0                                                  // set the initial state to 0 so that when you call this.state, it will be 0.
      }
    }
    render() {
      return (
        <div>
          <p>The current count: {this.state.count}</p>
          <button>
            Add 1
          </button>
        </div>
      )
    }
  }
---------------------------------------------------------

## Add the "onClick" prop to wire the button to trigger when clicked.
To wire code to be triggered when a button is clicked, we need to add a prop to the BUTTON JSX ITSELF!
Remember that within the props object there are a number properties you can select. IN this case, we want "onClick".
---------------------------------------------------------------------------
  class Counter extends React.Component {
    constructor(props) {
      super(props)
      this.state = { 
        count: 0 
      }
    }
    render() {
      return (
        <div>
          <p>The current count: {this.state.count}</p>
          <button onClick={function() { console.log('clicked!') }} >        // add the "onClick" prop.
            Add 1
          </button>
        </div>
      )
    }
  }
----------------------------------------------------------------------------

## To make code tidy, move the event handler to a seperate method.
However, a full event handler is going to be very cluttered, so its best to move the event handler
to a method on the class called "handleButtonClick"
---------------------------------------------------------------------------
  class Counter extends React.Component {
    constructor(props) {
      super(props)
      this.state = { 
        count: 0 
      }
    }
    handleButtonClick() {                                                  // 2. Inserted the "handleClickButton" method before render.
      console.log(this.state.count);                                       // 3. and to test, when you click "add 1", it will show the clicks you make at that time.
    } 
    render() {
      return (
        <div>
          <p>The current count: {this.state.count}</p>
          <button onClick={this.handleButtonClick} >                        // 1. changed to a method on the class called "handleButtonClick"
            Add 1
          </button>
        </div>
      )
    }
  }
----------------------------------------------------------------------------

## Use an arrow function to avoid typeerrors.
At this point, you will get an error that reads "TypeError: Cannot read property 'state' of undefined". Apparently this is a bug. This means
that we are trying to read a property called state ona variable thats currently set to undefined.  We want to read "this",
but right now it is set to undefined. To solve this, use an ARROW FUNCTION...not a function. Why? Because the arrow function makes sure that
the "this" is refering to the class instance.
------------------------------------------------------------------------
  class Counter extends React.Component {
    constructor(props) {
      super(props)
      this.state = { 
        count: 0 
      }
    }
    handleButtonClick = () => {                                               // use an arrow function for the method to avoid the error bug.
      console.log(this.state.count)
    }
    render() {
      return (
        <div>
          <p>The current count: {this.state.count}</p>
          <button onClick={this.handleButtonClick}>
            Add 1
          </button>
        </div>
      )
    }
  }
------------------------------------------------------------------------


## To set the state, use this.setState method.
When you use "this.setState", you update the state of a component that has been mounted and pass in an object to "merge" over the toMatchSnapshot
of an exisiting state (like Object.assign).  In the example case below, what we are doing is updating the state of count and merging the initial
state to the value of newCount.   

Note here that state updates go hand-in-hand with event handlers. In this example case, the the state update occurs in the "handleButtonClick"
action the user takes. But keep in mind the "this" problem which is a bug that needs to be fixed in future versions.

==clean up==
Now that the event listener is properly hooked up and setup in sich a way where it avoid the bug error, you can add your code
for the onClick action. At this point in the example, we have an exisiting count of 0 supplied by the current state. 

When the user clicks on the button, the "onClick" prop calls "this.handleButtonClick" which in turn executes the action we want 
to happen when the user clicks. In this case, we want to increment by one for every click the user makes. 

To implement this, we first create a variable called "newCount" and store it as a constant. The value will be the current count, 
(this.state.count) plus 1.

Then, to set the new state, use this.setState with the incrementing variable we just created.
-------------------------------------------------------------------------
  class Counter extends React.Component {
    constructor(props) {
      super(props)
      this.state = { 
        count: 0 
      }
    }
    handleButtonClick = () => {                                           
      const newCount = this.state.count + 1;                                 // variable that increments the count by 1.
      this.setState({                                                        // sets the new state count.
        count: newCount
      })
    }
    render() {
      return (
        <div>
          <p>The current count: {this.state.count}</p>
          <button onClick={this.handleButtonClick}>
            Add 1
          </button>
        </div>
      )
    }
  }
-------------------------------------------------------------------------
